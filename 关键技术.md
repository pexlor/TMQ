### 一种可以任意位置消费的无锁队列

无锁队列是通过CAS算法来实现的一种支持并发读写的队列，具备高效的元素入队、出队操作。常见的无锁队列一般通过链表或者环形数组来实现。但无论哪种实现方式，我们总能够看出现有无锁队列都有一个共同特点，那就是队尾添加元素，队头消费元素，支持元素的先入先出特性。然而，是否能有一种无锁队列可以支持任意位置的消费呢？

环形数组实现的无锁队列很大的缺陷在于容量未支持扩展，其实现虽然简洁，但通用性不高。链表实现的无锁队列具备更好的通用性，基于此来实现任意位置消费的无锁队列，是在现有的基础上添加任意位置元素的消费能力。对于队列任意位置的消费，将直接从中间破坏链接的结构，如何保障破坏-修复链表的操作具备原子性、并发安全性，是支持无锁队列任意位置消费的关键。解决好这个问题，自然也就能够实现任意位置消费的无锁队列，所以，初步思考来看，任意位置消费的无锁队列是可行的。

### 1. 状态控制

用一个变量来记录元素（节点）的状态，达到控制元素行为的目的，也称之为状态控制。对于链表无锁队列，状态控制用于记录当前节点的读者计数，同时，也用于解决内存复用导致的CAS-ABA问题。当读者计数不为0，说明当前元素存在并发读的情况，元素不允许被释放。当元素读计数为0，说明没有读者了，这个时候，元素能够被安全释放。这个过程，正是链表无锁队列的安全读机制。

但从Header消费的无锁链表来说，并发消费和读操作仅仅发生在头结点，为了能够任意位置消费元素，并发消费和读操作将发生在无锁链表的每个节点上。这也是我们对无锁链表关于状态的概念扩展，也是实现任意位置消费无锁队列的基础条件。

对于状态的变更，通过CAS来完成，不同的状态，对应不同的操作，存在并发的地方，通过自旋来避免冲突，以下，我们给出两种状态控制算法，来实现任意位置消费的无锁队列。

### 2. 冲突场景

假设，任意位置消费的无锁队列对节点消费的操作是，首先，记录前一个节点，然后尝试消费当前节点，如果成功，则将前一个节点的next修改为next->next。节点消费的伪代码：

```

Node* pre;
Node* cur;
// 当cur节点被消费，则做如下操作：
pre.next = cur.next

```

冲突发生在链表的写入过程中，有写-写冲突、读-写冲突，具体表现为：

![](images/Queue_2.png)

如上图，假定两个线程进入并访问队列。每次，线程都将占据第一个元素，然后开始消费第二个元素。这就意味着，线程即将读第二个元素，同时写第一个元素。当发生冲突的时候，将发生如上的4个场景，分别是：安全读写（无冲突），读-写冲突，写-写冲突和写-读冲突。总体来说，可以归为3类，无冲突、读写冲突和写写冲突。其中，后面的两个冲突是需要解决或者规避的。

### 3. 基于自旋等待的方法

自旋等待是CAS无锁编程常用的并发冲突解决办法，类似于锁操作，不同的是，当遇到冲突的时候，线程将通过自旋的方式等待直到另一个线程离开。

#### 3.1 状态划分

在上面的冲突场景中，可以看出，冲突发生在读、写的并发操作上。于是，状态变量可以划分为两类，读和写，读是一中共享操作，可以看做计数器能力，写是独占操作，可以通过开关量控制。设定状态为32位无符号整形数，当然，也可以根据具体的并发量设置状态变量的长度。以下，我们以32位无符号整形数作为状态记录。同时，一个32位整形数也是CAS可以操作的值。

![](images/Queue_32.png)

#### 3.2 并发控制

因为从链表中取出一个元素，需要同时占据两个元素：第一元素和第二元素，并将第一元素的下一个元素修改为第三元素，从而完成一次消费。我们需要的并发控制就是要让第一元素和第二元素同时处于无冲突的状态。那么，需要做的操作就是，为第一元素上写标记，拦截其他读、写者的进入，然后，等待第一元素、第二元素上已有读者、写者的离开。消费的并发控制流如下：

![](images/Queue_4.png)

当发生元素消费的时候，当前读者将在第一元素竞争写标记。有两种结果，竞争成功和竞争失败。如果竞争成功，则进入自旋等待阶段。有两个过程需要自旋等待，其一是等待第一元素上的全部读者离开，其二是等待第二元素上的全部读写者离开。此时，第二元素的消费就是独占，进入无冲突的场景。

需要注意的是，当竞争写标记成功，也就是屏蔽了其它读、写者进入第一元素。如果，竞争失败，或者无消费元素，读者将不断进行进入-离开的操作，直到末尾(Tail)，返回消费失败，也就是一次消费完成。

如上逻辑，伪代码：

```
// 消费node节点，node节点即为第一元素，Node->next为第二元素。
function Consume(Node* node) {
	Node* result = nullptr;
	unsigned int state = node->state;
	// 清除写标记
	state = state & 0x7fffffff;
	// 向state添加写标记，作为expect
	unsigned int expect = state | 0x80000000;
	// CAS竞争写标记
	if(CAS(&(node->state), &state, &expect)){
		// 如果成功，说明竞争到了第一元素的写标记，讲next作为结果，开始等待消费者离开
		result = node->next;
		// 循环等待，直到第一元素上的消费者只剩下当前一个
		while((node->state & 0x7fffffff) != 1);
		// 循环等待，直到第二元素上的消费者没有
		while(node->next.state != 0);
		// 冲突区域进入安全状态，拆解第二元素，拆解前检查是否为尾结点
		Node* tailLocal = node->next;
		Node* tailNext = nullptr;
		// 如果被消费元素是tail，CAS操作，将尾元素的next设置为empty元素，用于阻止生产者，同时，将第一元素的next设置为空，正式成为尾指针
		if(node->next == tail && CAS(&(tail->next), &tailNext, &empty)){
			// 阻止生产者成功，修改尾指针指向第一元素，并将尾指针的next置空
			tail = node;
			tail.next = nullptr;
		}else{
			// 没有达到末尾，或者末尾已经添加了新元素（CAS失败），通用处理逻辑
			node->next = node->next->next
		}
		// 释放写标记
		node->state &= 0x7fffffff;
	}else{
		// 如果失败，说明对第二元素的消费失败，尽快离开冲突区
		Enter(node->next);
		Leave(node);
	}
	return result;
}

```

伪代码中，也已经指出了消费者在消费元素的过程中几个关键步骤和处理方法：

+ 1. 竞争写标记的时候要清理写标记，保证只有一个消费者成功添加写标记
+ 2. CAS操作成功，代表对第一元素添加写标记成功，否则代表消费元素失败
+ 3. 通过While循环等待其他消费者离开，这里直接读取state变量，要求CAS操作为强内存序
+ 4. 对于尾节点的消费，我们需要让生产者和消费者在tail->next形成并发竞争
+ 5. 消费竞争失败，或者在第一、二元素上的消费者，将尽快离开冲突区域

#### 3.3 自旋等待方法的缺陷

虽然，自旋等待方法能够避开锁机制，通过CAS和自旋完成任意位置消费的无锁队列。但在冲突解决过程中，存在较多自旋等待。

+ 其一，等待第一，第二元素上的消费者离开，如果在第二及连续元素上，有消费者正在消费，就会存在链式等待问题；
+ 其次，消费者与生产者发生冲突的时候，消费者可能阻止生产者，造成生产者等待问题；
+ 其三，一次元素消费之后，消费者丢失当前状态，下次必须从头开始搜索，存在多余遍历问题。

### 4. 基于消费者协作的方法

消费元素的过程，除去自旋等待过程，可以分为三步：其一，竞争写标记独占第一元素；其二，将待消费的第二元素从链表中拆下；其三，取值并释放元素。其中，步骤二、步骤三因为没有对应的原子操作，在并发过程中不得不进行自旋保护。并发是因为多个消费者同时进入了冲突区，一个消费者必须等待其它消费者离开才能操作，能否反过来：最后一个离开的消费者来进行冲突清理，将已消费的元素拆除。同时，对于拆除的元素，采用同样的并发处理：最后一个离开该元素的消费者负责释放节点呢？！答案是肯定的，这也是基于消费者协作的方法的核心思想：并发冲突过程中，最后一个离开的消费者负责清理消费过的元素，已消费过的元素，最后一个离开的负责释放该元素。不难看出，基于协作的消费方法能够有效减少自旋等待，同时，也能够支持对节点的持有（停留在该节点）操作。

#### 4.1 状态扩展

相比于自旋等待方法，基于消费者协作的方法具备更多的状态，状态值也变得更多，具体的State扩展如下：

![](images/Queue_5.png)

可以看到，State被划分为4个部分：消费标记，写标记，读计数，暂留计数，具体含义：

+ **消费标记：** 表示当前元素是否已经被消费，Removed，与写标记、消费操作互斥
+ **写标记：** 表示当前元素是否处于修改状态，也就是独占状态，与读计数互斥
+ **读计数：** 表示正在读取当前元素的信息的个数，此时元素不能被修改
+ **暂留计数：** 表示停留在当前节点上消费者的个数

#### 4.2 并发控制

协作消费是在自旋等待的基础上进行的进一步优化，部分状态标记依然保持原有含义。以下列出状态的具体冲突含义：

|状态|并发原则|说明|
|----|----|----|
|消费标记|只允许消费一次，与写标记，可以与停留标记共存|通过CAS来竞争消费标记，相当于将元素移除，但不改变链表|
|写标记|只允许一个消费者进行写，与读标记、消费标记互斥，可以与停留标记共存|通过CAS来竞争写标记，只允许一个消费者获取写标记，进而独占该元素，其他消费不能进入，可以离开|
|读计数|进入下一个元素前，将读计数加一，进入成功后，将读计数减一，与写标记互斥，与消费标记、停留标记可共存|通过 CAS对当前元素的读计数加减一，当一个元素正在读的时候，其next不能被修改|
|停留计数|进入节点后，停留计数加一，离开节点后停留计数减一，与消费标记、写标记、读计数可以并存|停留计数可以认为是对元素的引用，消费者成功进入一个元素后相当于对元素进行了引用，链表对元素的连接是一种特殊的引用，所以，默认情况下，被添加到链表的每个节点都是1|

以上，对于状态的操作都是通过CAS来完成，不同的状态转换前需要遵循如何原则。默认情况下，新元素添加进链表后随即被链表引用，引用计数为1；从链表将元素拆除后，停留计数减一，当停留计数为0的时候，元素未被任何消费者或者其他节点引用，这样的节点可以被释放。

#### 4.3 并发消费流程

主消费逻辑已经相当简单，就是对目标元素添加Removed消费标记，这个操作是CAS操作，有成功和失败两种结果，通过对结果的判断来确定当前消费者是否成功消费当前元素。如果一个节点Removed标为False，当前消费者就可以继续尝试消费该元素。当元素被当前消费者消费的时候，可以立即返回当前节点的值，此时被消费的节点将停留在链表中。

![](images/Queue_7.png)

当消费者继续迭代遍历链表的时候，进入下一个元素前，需要对当前元素添加读计数，用于阻止当前元素被改写，从而保护next元素。进入成功后，会立即解除读计数，能够减少自旋等待时间。

离开一个节点的逻辑则相对复杂，因为协作消费方法要求最后一个离开当前节点的消费者需要负责清理已经消费的节点。这就是清理逻辑和释放逻辑。

释放逻辑中，当一个元素离开当前节点后，发现其停留者已经为0了，说明当前消费者是最后一个离开当前元素的，安全释放。

清理逻辑中，主要是将已经消费但还停留在链表中的元素进行清理。此时，最后一个离开冲突区的消费者将对节点添加写标记，阻止新的消费者进入，保障当前安全区域，然后解除已消费的元素，解除消费元素不仅从需要修改next的指向，同时，引用计数也要随之消减。消减为0的引用（停留计数）将被及时安全移除。最后，消费者清除写标记，继续进行迭代搜索。

具体的并发消费流程可以见上图。

#### 4.4 入队并发控制

入队的并发有3种类型，分别是：生产者与生产者的并发，生产者与消费者的并发，以及消费者与消费者的并发。生产者与生产者之间的并发很好理解，就是并发添加新的元素，一方面添加新元素，另一方面修改尾指针到新的位置。生产者与消费者之间的并发在于移除尾部元素，并修改尾指针到上一个位置。而消费者与消费者在尾部依然存在并发，因为消费者需要竞争消费尾部元素。

这里的并发涉及到了尾部节点，以及修改尾指针，其中，尾部节点是可变的，同时还需要跟随修改尾指针，在生产者、消费者之间，情况会变得更加复杂。我们需要的是一种机制可以同时控制以上3种类型的并发。尾指针就是一个合适只选。可以通过对尾指针的并发控制来控制生产者与生产者，消费者与消费者以及生产者与消费者之间的并发。

**持有旧的尾指针，总是把尾指针指向新的节点。**

以上是入队并发控制的核心思想。具体地，对于生产者，每次获取尾指针，并将尾指针修改为新入队的节点，直到操作成功，然后将该入队的新节点（节点集）赋值到原来的尾节点。

对于消费者，如果遇到尾指针，则尝试将尾指针修改到上一个普通节点（未被消费的节点），此时的CAS操作会有两种结果，成功或者失败。如果成功，说明我们修改尾节点前移到了普通节点，生产者将对新的尾节点添加元素，尽管尾节点并不为空。如果失败，则说明生产者修改并后移了尾节点，为了能够正确移除消费过的元素，生产者必须等待元素正常入队后才能继续进行清理操作。

入队并发控制的具体流程图如下：

![](images/Queue_8.png)

如上图，详细描述一Tail尾指针作为并发变量时，生产者、消费者相关的尾部并发控制流程。

#### 4.5 基于协作消费的并发模型

基于消费者协作的并发模型上，存在着多种状态的元素，读、写、暂留、已消费，甚至几种状态的组合。队列上，除了节点，我们还能观察到暂留的消费者，以及正在添加元素的生产者。在多生产者、多消费者的高并发场景下，我们能够看到如下的鱼骨模型：

![](images/Queue_9.png)

每个元素都存在多种状态，这里仅仅标记了元素的引用计数，包括链表引用以及消费者的停留引用。如下，Header的引用计数为1，表示头引用。C5所在的节点引用计数为4，除了3个链接引用，另一个就是消费者的停留引用。我们并不关心引用计数的多少，我们关心的是引用计数是否为0，因为只有引用计数为0的状态下，才能进行元素释放操作。同时，引用计数为0的元素也是不能被继续访问的元素。

以Tail-0为分界线，左边是消费者，以及正在被消费的元素，右边是正在添加的元素，已经生产者。途中可以看到，同一时刻有多个新元素正在被添加，相互之间无需等待，这也是生产者能够支持高并发的原因所在。如上图，描述了生产者生产和添加元素的过程，例如P1生产了两个元素，通过CAS将Tail指针由Tail-0移动到Tail-1，如果成功，则将这两个元素添加到Tail-0末尾，其他生产者以此类推。可以看出来，生产者添加新元素到队列没有耗时操作，其效率理论上逼近单线程。

左边是一个鱼骨消费模型。已经消费的元素没有立即从队列中移除并释放，因为其末端有一个停留的消费者。分支与主线上元素的状态不同，分支上的元素是已经被消费，但未释放的元素；主骨上是普通元素，以及刚刚被消费的元素。当最后一个消费者离开主线上的并发区域的时候，就会将已消费的元素拆解到分支上。如果被消费的元素链表上，停留有消费者，那么，就会形成如上的分支图。可以看出，当C1被唤醒的时候，将沿着链表的方向向前搜索，进而进入主线。由于分支元素都是已经消费过的元素，因此，分支上的消费者能够快速进入主线。C1的离开必然导致其停留节点的引用计数减一，结果为0，这就自然触发了释放逻辑。

鱼骨模型图是基于协作并发导致的生产者与消费者运行时模型，支持高并发的同时，尽快释放元素。当然，以上示意图仅仅是运行时刻的结果图，运行过程中，鱼骨图也会不断变化，包括状态转换、分支缩小以及元素归位，最终，也就是没有新元素入队，以及消费者都离开的状态，队列将变成一条简单的单向链表。

### 5. 总结

以上给出了两种任意位置消费的无锁队列，其中，第二种方法是对前一种方法的优化，包括减少自旋等待，支持消费者停留（减少从头搜索的多余浪费），提高生产者、消费者的并发，最终有效提升了并发效率。当然，基于消费者协作的无锁队列也存在弊端，那就是已经消费的元素可能得不到及时释放。准对这个问题，采取壳优化的方式，当元素被消费了之后，将其消息体首先释放，节点最后释放，以此来降低节点带来的内存消耗。
