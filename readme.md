# TMQ消息通信基础服务

TMQ消息通信基础服务是为高并发、高吞吐、高可靠性而设计的跨平台基础消息服务。通过TMQ，可以实现一对一、一对多、多对多的消息通信，进而实现组件、模块之间的松耦合。TMQ消息通信封装了消息队列，借鉴了消息订阅系统的概念。为实现扩平台特性，核心代码通过基础的C/C++实现。

### 1. 基础设计

如下，TMQ的基础框架设计：

![](images/10.png)

TMQ主要包含三部分：对外接口、消息池和分发器。以下，对这三部分概要介绍：

**对外接口：** 对外接口围绕简单、实用的原则，通过纯虚函数定义接口。接口的主要操作包括发布、订阅和拾取，以及一个回调接口。另外，为实现消息的统一封装，TMQ对外提供了TMQMsg定义，包括消息体，消息长度，以及优先级。

**消息池：** 消息池是对消息队列的一个封装，为使逻辑设计的简单、易懂，每个主题分配一个消息队列，进而减少发布、分发过程中的相互干扰。消息池中，目前定义了3中类型的消息：topic消息，这部分消息是通过publish接口推入，等待分发、消费的消息；__Sent__消息，该消息属于TMQ内置消息，其topic为\_\_Sent\_\_，用于记录成功分发的消息，与此同时，这个topic的消息还有另一种功能，那就是实现消息回执，关于消息回执，后续介绍；最后，是历史消息，这部分消息将存放已经分发完成的消息，历史消息不会持续保持，将受到资源、策略的控制。

**分发器：** 分发器是一个可执行单元，对外提供Wakeup操作，用户唤醒执行单元。TMQ中，分发器通过线程实现，并支持可延展、懒加载和防阻塞。在分发器中，将持有通过Subcribe注册的订阅者，相同topic的订阅者放在相同的队列。当有新消息进入消息池之后，分发器将通过Poll操作获取等待状态的消息，并将其分发到正确的订阅者。如上图，消息分发器中其实可以有多个可行性单元，一方面提高分发的吞吐，另一方面用于解决可能的阻塞问题，具体解决过程见下文。

### 2. 内部机制

TMQ内部是如何工作的呢？首先，开发者通过Subcribe接口注册订阅者：一个回调接口，然后在回调接口中处理自己的逻辑；其次，通过Pick操作拾取错过的消息，Pick操作是可选的；最后，如果需要与其它组件通信，可以通过Publish接口发布消息。以testTopic主题订阅、发布为例，来看一看一个消息的流转过程。首先，通过Subcribe注册一个订阅者：

```
// 实现回调接口
class OCReceiver : public TMQReceiver{
    void OnReceive(const TMQMsg *msg) override{
        ...
    }
};
// 订阅testTopic的消息
订阅testTopic的消息

Topic::GetTopicInstance()->Subscribe("testTopic", new OCReceiver());

```
此时，订阅者OCReceiver将穿过消息池，被放到分发器中。在分发器中，将保持主题、订阅者之间的关系，一个主题对应多个订阅者。

另一方面，开发者通过Publish接口发送主题为testTopic的消息：

```
const char* data = "hello from tmq";
Topic::GetTopicInstance()->Publish("testTopic", (void*)data, strlen(data));
```
如上，data消息通过Publish之后，就会进入到主题为testTopic的消息队列中；与此同时，一次发布，将会触发一次分发器的Wakeup，当分发器被唤醒之后，通过消息池的Poll操作拉取一条等待状态的消息，然后，找到这个消息对应主题的订阅者，依次调用每个订阅者，实现消息到订阅者的分发。分发器一旦被唤醒，将持续拉取消息，直到拉取不到消息才会再次进入休眠。

消息被分发之后，随即进入主题为\_\_Sent\_\_的消息队列，当分发器空闲的时候，就会分发\_\_Sent\_\_队列中的消息，开发者可以通过订阅该主题的消息，实现消息回执。消息回执结束后，该消息正式进入历史消息队列，这个队列里面的消息将受资源、策略的限制，将保存有限量的消息。

那么，在这个过程中，如何保证消息的有序性、不重复、优先级、消息回执，以及如何保证高吞吐和处理分发器的调用阻塞问题呢？

### 3. 关键问题

TMQ基础服务的特性要求了其高可用性，不仅需要解决消息订阅、分发过程，同时还需要解决消息机制、性能、并发等问题。以下，对几个TMQ消息队列的关键问题进行解析说明。

#### 3.1 有序性

TMQ采用队列的机制，是一个天然的先入先出队列。如果所有消息都在一个队列中，那么，先入先出是必然的，然后，由于消息队列是以主题为单位划分的，这就意味着，消息队列被拆分成了"主题队列"。所以，TMQ其实保证了每个主题下队列的先入先出，但并未保证不同主题下队列的有序性。例如，topic1队列的每个消息处理都需要1min，而topic2队列中每个消息处理仅仅是毫秒级，明显，topic2中的消息不能等topic1中的消除处理完再处理，将会造成严重的阻塞问题。

另外，分发器是一个多执行器的功能单元，内部可以有1到N个的线程，为了保证一个topic不被多个线程分发，造成乱序，消息分发的过程是一个集中处理的过程。在这个过程中，同一topic下的消息，只有最前面的消息分发完成之后，才进行下一条消息分发，保证分发、接收消息的有序性。

#### 3.2 不重复性

消息的重复分发来源于消息发送过程中的异常导致了消息重发，或者消息丢失。对于发送过程的异常，例如socket错误，通信中断等，由于TMQ消息分发是一个回调的过程，要求开发者在回调过程中不能出现致命错误，否则直接导致程序的崩溃，由于这个异常无法保护，且回调过程是方法的调用过程，因此，程序本身也就用于了不重复性。

#### 3.3 消息回执

对于消息发送者来说，如何知道TMQ已经将消息分发了呢？这就是TMQ内部的消息回执机制，当一条消息分发结束之后，不会理解进入历史消息队列，而是还将经历一个消息回执的过程。这个消息回执的过程与普通消息订阅机制类似，调用者可以定于topic为\_\_Sent\_\_的内部主题消息，并接收其中的消息ID来判断消息某个消息是否已经成功。

#### 3.4 调用阻塞

分发器是一个可执行单元，可以有1个线程，可以有多个线程，与消息池中的主题是一种多对多的关系。在消息分发过程中，无法预知订阅者在订阅方法中做哪些操作，如果一个操作耗时，甚至卡死分发器，那么，将导致后续的消息全部阻塞。所以，分发器在设计的过程中是可延展的，当分发器其中有一个线程卡住的时候，将创建、唤醒下一个线程，继续分发消息。没有消息的时候，已经被唤醒的线程将进入休眠阶段，减少消耗。

#### 3.5 历史消息

消息被分发完成之后，并非直接移除，而是有一个停留的阶段。历史消息的必要性在于，如果一个订阅者订阅较晚，想要获取已经发不过去的消息，那么，这个功能就十分有用。推荐尽早订阅消息，因为，历史消息是对已发布消息的一种备份，是一种资源消耗，不可能一直备份下去，在过期、资源限制的情况下，历史消息将被移除。目前，TMQ历史消息为每个主题预留固定128个消息，占满之后，队列前的消息将移除，新的历史消息放到队尾。

### 总结

TMQ消息通信作为最基础的服务，已经基本实现了基于主题的消息发布、接收、拾取功能，C/C++语言进行的核心设计，目前，已经能够支持Android、iOS、PC以及Mac平台。虽然，TMQ已经尝试解决各种消息分发过程中的问题，但仍然存在一些极端问题，例如重要消息、优先级、性能等，将在后续的发展中继续尝试解决！



# TMQ消息通信基础服务

TMQ消息通信基础服务是为高并发、高吞吐、高可靠性而设计的跨平台基础消息服务。通过TMQ，可以实现一对一、一对多、多对多的消息通信，进而实现组件、模块之间的松耦合。TMQ消息通信封装了消息队列，借鉴了消息订阅系统的概念。为实现扩平台特性，核心代码通过基础的C/C++实现。

### 1. 基础设计

如下，TMQ的基础框架设计：

![](images/10.png)

TMQ主要包含三部分：对外接口、消息池和分发器。以下，对这三部分概要介绍：

**对外接口：** 对外接口围绕简单、实用的原则，通过纯虚函数定义接口。接口的主要操作包括发布、订阅和拾取，以及一个回调接口。另外，为实现消息的统一封装，TMQ对外提供了TMQMsg定义，包括消息体，消息长度，以及优先级。

**消息池：** 消息池是对消息队列的一个封装，为使逻辑设计的简单、易懂，每个主题分配一个消息队列，进而减少发布、分发过程中的相互干扰。消息池中，目前定义了3中类型的消息：topic消息，这部分消息是通过publish接口推入，等待分发、消费的消息；__Sent__消息，该消息属于TMQ内置消息，其topic为\_\_Sent\_\_，用于记录成功分发的消息，与此同时，这个topic的消息还有另一种功能，那就是实现消息回执，关于消息回执，后续介绍；最后，是历史消息，这部分消息将存放已经分发完成的消息，历史消息不会持续保持，将受到资源、策略的控制。

**分发器：** 分发器是一个可执行单元，对外提供Wakeup操作，用户唤醒执行单元。TMQ中，分发器通过线程实现，并支持可延展、懒加载和防阻塞。在分发器中，将持有通过Subcribe注册的订阅者，相同topic的订阅者放在相同的队列。当有新消息进入消息池之后，分发器将通过Poll操作获取等待状态的消息，并将其分发到正确的订阅者。如上图，消息分发器中其实可以有多个可行性单元，一方面提高分发的吞吐，另一方面用于解决可能的阻塞问题，具体解决过程见下文。

### 2. 内部机制

TMQ内部是如何工作的呢？首先，开发者通过Subcribe接口注册订阅者：一个回调接口，然后在回调接口中处理自己的逻辑；其次，通过Pick操作拾取错过的消息，Pick操作是可选的；最后，如果需要与其它组件通信，可以通过Publish接口发布消息。以testTopic主题订阅、发布为例，来看一看一个消息的流转过程。首先，通过Subcribe注册一个订阅者：

```
// 实现回调接口
class OCReceiver : public TMQReceiver{
    void OnReceive(const TMQMsg *msg) override{
        ...
    }
};
// 订阅testTopic的消息
订阅testTopic的消息

Topic::GetTopicInstance()->Subscribe("testTopic", new OCReceiver());

```
此时，订阅者OCReceiver将穿过消息池，被放到分发器中。在分发器中，将保持主题、订阅者之间的关系，一个主题对应多个订阅者。

另一方面，开发者通过Publish接口发送主题为testTopic的消息：

```
const char* data = "hello from tmq";
Topic::GetTopicInstance()->Publish("testTopic", (void*)data, strlen(data));
```
如上，data消息通过Publish之后，就会进入到主题为testTopic的消息队列中；与此同时，一次发布，将会触发一次分发器的Wakeup，当分发器被唤醒之后，通过消息池的Poll操作拉取一条等待状态的消息，然后，找到这个消息对应主题的订阅者，依次调用每个订阅者，实现消息到订阅者的分发。分发器一旦被唤醒，将持续拉取消息，直到拉取不到消息才会再次进入休眠。

消息被分发之后，随即进入主题为\_\_Sent\_\_的消息队列，当分发器空闲的时候，就会分发\_\_Sent\_\_队列中的消息，开发者可以通过订阅该主题的消息，实现消息回执。消息回执结束后，该消息正式进入历史消息队列，这个队列里面的消息将受资源、策略的限制，将保存有限量的消息。

那么，在这个过程中，如何保证消息的有序性、不重复、优先级、消息回执，以及如何保证高吞吐和处理分发器的调用阻塞问题呢？

### 3. 关键问题

TMQ基础服务的特性要求了其高可用性，不仅需要解决消息订阅、分发过程，同时还需要解决消息机制、性能、并发等问题。以下，对几个TMQ消息队列的关键问题进行解析说明。

#### 3.1 有序性

TMQ采用队列的机制，是一个天然的先入先出队列。如果所有消息都在一个队列中，那么，先入先出是必然的，然后，由于消息队列是以主题为单位划分的，这就意味着，消息队列被拆分成了"主题队列"。所以，TMQ其实保证了每个主题下队列的先入先出，但并未保证不同主题下队列的有序性。例如，topic1队列的每个消息处理都需要1min，而topic2队列中每个消息处理仅仅是毫秒级，明显，topic2中的消息不能等topic1中的消除处理完再处理，将会造成严重的阻塞问题。

另外，分发器是一个多执行器的功能单元，内部可以有1到N个的线程，为了保证一个topic不被多个线程分发，造成乱序，消息分发的过程是一个集中处理的过程。在这个过程中，同一topic下的消息，只有最前面的消息分发完成之后，才进行下一条消息分发，保证分发、接收消息的有序性。

#### 3.2 不重复性

消息的重复分发来源于消息发送过程中的异常导致了消息重发，或者消息丢失。对于发送过程的异常，例如socket错误，通信中断等，由于TMQ消息分发是一个回调的过程，要求开发者在回调过程中不能出现致命错误，否则直接导致程序的崩溃，由于这个异常无法保护，且回调过程是方法的调用过程，因此，程序本身也就用于了不重复性。

#### 3.3 消息回执

对于消息发送者来说，如何知道TMQ已经将消息分发了呢？这就是TMQ内部的消息回执机制，当一条消息分发结束之后，不会理解进入历史消息队列，而是还将经历一个消息回执的过程。这个消息回执的过程与普通消息订阅机制类似，调用者可以定于topic为\_\_Sent\_\_的内部主题消息，并接收其中的消息ID来判断消息某个消息是否已经成功。

#### 3.4 调用阻塞

分发器是一个可执行单元，可以有1个线程，可以有多个线程，与消息池中的主题是一种多对多的关系。在消息分发过程中，无法预知订阅者在订阅方法中做哪些操作，如果一个操作耗时，甚至卡死分发器，那么，将导致后续的消息全部阻塞。所以，分发器在设计的过程中是可延展的，当分发器其中有一个线程卡住的时候，将创建、唤醒下一个线程，继续分发消息。没有消息的时候，已经被唤醒的线程将进入休眠阶段，减少消耗。

#### 3.5 历史消息

消息被分发完成之后，并非直接移除，而是有一个停留的阶段。历史消息的必要性在于，如果一个订阅者订阅较晚，想要获取已经发不过去的消息，那么，这个功能就十分有用。推荐尽早订阅消息，因为，历史消息是对已发布消息的一种备份，是一种资源消耗，不可能一直备份下去，在过期、资源限制的情况下，历史消息将被移除。目前，TMQ历史消息为每个主题预留固定128个消息，占满之后，队列前的消息将移除，新的历史消息放到队尾。

### 总结

TMQ消息通信作为最基础的服务，已经基本实现了基于主题的消息发布、接收、拾取功能，C/C++语言进行的核心设计，目前，已经能够支持Android、iOS、PC以及Mac平台。虽然，TMQ已经尝试解决各种消息分发过程中的问题，但仍然存在一些极端问题，例如重要消息、优先级、性能等，将在后续的发展中继续尝试解决！



